// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// includes
#include <setjmp.h>

//the dec of  jmp_buf ids
jmp_buf buf_0;
jmp_buf buf_1;
jmp_buf buf_2;

// structures
struct Sum
{
    struct Sum_vtable *vptr;
    int isObjOrArray;
    unsigned length;
    void *forwarding;
};

struct Doit
{
    struct Doit_vtable *vptr;
    int isObjOrArray;
    unsigned length;
    void *forwarding;
};

// vtables structures
struct Sum_vtable
{
};

struct Doit_vtable
{
    char *Doit_gc_map;
    int(*doit)(struct Doit*, int);
    int(*f)(struct Doit*);
    int(*testjmp)(struct Doit*);
};

// method declarations
int Doit_doit(struct Doit * thiss, int n);
int Doit_f(struct Doit * thiss);
int Doit_testjmp(struct Doit * thiss);

// vtables
struct Sum_vtable Sum_vtable_ = 
{
};

struct Doit_vtable Doit_vtable_ = 
{
    "",
    Doit_doit,
    Doit_f,
    Doit_testjmp,
};

// GC stack frames
struct Tiger_main_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
    struct Doit * x_0;
};

struct Doit_doit_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
    struct Doit * x_1;
};

struct Doit_f_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
    struct Doit * x_2;
};

struct Doit_testjmp_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
};

// memory GC maps
int Tiger_main_locals_gc_map = 1;

char *Doit_doit_arguments_gc_map = "10";
int Doit_doit_locals_gc_map = 1;

char *Doit_f_arguments_gc_map = "1";
int Doit_f_locals_gc_map = 1;

char *Doit_testjmp_arguments_gc_map = "1";
int Doit_testjmp_locals_gc_map = 0;

extern void *previous;

// methods
int Doit_doit(struct Doit * thiss, int n)
{
    struct Doit_doit_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = Doit_doit_arguments_gc_map;
    frame.arguments_base_address = (int *)&thiss;
    frame.locals_gc_map = Doit_doit_locals_gc_map;
    int sum;
    int i;
    frame.x_1 = 0;

    i = 0;
    sum = 0;
    if(!setjmp(buf_0))
    {
        while(i < n)
        {
            sum = sum + i;
            i = i + 1;
            System_out_println(1);
            if(!setjmp(buf_1))
            {
                System_out_println(6);
                longjmp(buf_1,1);
            }
            else
            {
                System_out_println(7);
            }
            sum = (frame.x_1=thiss, frame.x_1->vptr->f(frame.x_1));
        }
    }
    else
    {
        System_out_println(2);
    }
    if(!setjmp(buf_2))
    {
        System_out_println(8);
        longjmp(buf_2,1);
    }
    else
    {
        System_out_println(9);
    }
    previous = frame.prev;
    return sum;
}

int Doit_f(struct Doit * thiss)
{
    struct Doit_f_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = Doit_f_arguments_gc_map;
    frame.arguments_base_address = (int *)&thiss;
    frame.locals_gc_map = Doit_f_locals_gc_map;
    int i;
    frame.x_2 = 0;

    System_out_println(5);
    i = (frame.x_2=thiss, frame.x_2->vptr->testjmp(frame.x_2));
    previous = frame.prev;
    return 1;
}

int Doit_testjmp(struct Doit * thiss)
{
    struct Doit_testjmp_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = Doit_testjmp_arguments_gc_map;
    frame.arguments_base_address = (int *)&thiss;
    frame.locals_gc_map = Doit_testjmp_locals_gc_map;

    System_out_println(3);
    longjmp(buf_0,1);
    previous = frame.prev;
    return 1;
}

// main method
int Tiger_main()
{
    struct Tiger_main_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = 0;
    frame.arguments_base_address = 0;
    frame.locals_gc_map = Tiger_main_locals_gc_map;
    System_out_println((frame.x_0=((struct Doit*)(Tiger_new(&Doit_vtable_, sizeof(struct Doit)))), frame.x_0->vptr->doit(frame.x_0, 101)));
}

