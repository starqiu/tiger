// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// includes
#include <setjmp.h>
// structures
struct BinarySearch
{
    struct BinarySearch_vtable *vptr;
    int isObjOrArray;
    unsigned length;
    void *forwarding;
};

struct BS
{
    struct BS_vtable *vptr;
    int isObjOrArray;
    unsigned length;
    void *forwarding;
    int * number;
    int size;
};

// vtables structures
struct BinarySearch_vtable
{
};

struct BS_vtable
{
    char *BS_gc_map;
    int(*Start)(struct BS*, int);
    int(*Search)(struct BS*, int);
    int(*Div)(struct BS*, int);
    int(*Compare)(struct BS*, int, int);
    int(*Print)(struct BS*);
    int(*Init)(struct BS*, int);
};

// method declarations
int BS_Start(struct BS * thiss, int sz);
int BS_Search(struct BS * thiss, int num);
int BS_Div(struct BS * thiss, int num);
int BS_Compare(struct BS * thiss, int num1, int num2);
int BS_Print(struct BS * thiss);
int BS_Init(struct BS * thiss, int sz);

// vtables
struct BinarySearch_vtable BinarySearch_vtable_ = 
{
};

struct BS_vtable BS_vtable_ = 
{
    "10",
    BS_Start,
    BS_Search,
    BS_Div,
    BS_Compare,
    BS_Print,
    BS_Init,
};

// GC stack frames
struct Tiger_main_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
    struct BS * x_0;
};

struct BS_Start_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
    struct BS * x_1;
    struct BS * x_2;
    struct BS * x_3;
    struct BS * x_4;
    struct BS * x_5;
    struct BS * x_6;
    struct BS * x_7;
    struct BS * x_8;
    struct BS * x_9;
    struct BS * x_10;
};

struct BS_Search_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
    struct BS * x_11;
    struct BS * x_12;
    struct BS * x_13;
    struct BS * x_14;
};

struct BS_Div_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
};

struct BS_Compare_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
};

struct BS_Print_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
};

struct BS_Init_gc_frame
{
    void *prev;
    char *arguments_gc_map;
    int *arguments_base_address;
    int locals_gc_map;
};

// memory GC maps
int Tiger_main_locals_gc_map = 1;

char *BS_Start_arguments_gc_map = "10";
int BS_Start_locals_gc_map = 10;

char *BS_Search_arguments_gc_map = "10";
int BS_Search_locals_gc_map = 4;

char *BS_Div_arguments_gc_map = "10";
int BS_Div_locals_gc_map = 0;

char *BS_Compare_arguments_gc_map = "100";
int BS_Compare_locals_gc_map = 0;

char *BS_Print_arguments_gc_map = "1";
int BS_Print_locals_gc_map = 0;

char *BS_Init_arguments_gc_map = "10";
int BS_Init_locals_gc_map = 0;

extern void *previous;

// methods
int BS_Start(struct BS * thiss, int sz)
{
    struct BS_Start_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = BS_Start_arguments_gc_map;
    frame.arguments_base_address = (int *)&thiss;
    frame.locals_gc_map = BS_Start_locals_gc_map;
    int aux01;
    int aux02;
    frame.x_1 = 0;
    frame.x_2 = 0;
    frame.x_3 = 0;
    frame.x_4 = 0;
    frame.x_5 = 0;
    frame.x_6 = 0;
    frame.x_7 = 0;
    frame.x_8 = 0;
    frame.x_9 = 0;
    frame.x_10 = 0;

    aux01 = (frame.x_1=thiss, frame.x_1->vptr->Init(frame.x_1, sz));
    aux02 = (frame.x_2=thiss, frame.x_2->vptr->Print(frame.x_2));
    if((frame.x_3=thiss, frame.x_3->vptr->Search(frame.x_3, 8)))
        System_out_println(1);
    else
        System_out_println(0);
    if((frame.x_4=thiss, frame.x_4->vptr->Search(frame.x_4, 19)))
        System_out_println(1);
    else
        System_out_println(0);
    if((frame.x_5=thiss, frame.x_5->vptr->Search(frame.x_5, 20)))
        System_out_println(1);
    else
        System_out_println(0);
    if((frame.x_6=thiss, frame.x_6->vptr->Search(frame.x_6, 21)))
        System_out_println(1);
    else
        System_out_println(0);
    if((frame.x_7=thiss, frame.x_7->vptr->Search(frame.x_7, 37)))
        System_out_println(1);
    else
        System_out_println(0);
    if((frame.x_8=thiss, frame.x_8->vptr->Search(frame.x_8, 38)))
        System_out_println(1);
    else
        System_out_println(0);
    if((frame.x_9=thiss, frame.x_9->vptr->Search(frame.x_9, 39)))
        System_out_println(1);
    else
        System_out_println(0);
    if((frame.x_10=thiss, frame.x_10->vptr->Search(frame.x_10, 50)))
        System_out_println(1);
    else
        System_out_println(0);
    previous = frame.prev;
    return 999;
}

int BS_Search(struct BS * thiss, int num)
{
    struct BS_Search_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = BS_Search_arguments_gc_map;
    frame.arguments_base_address = (int *)&thiss;
    frame.locals_gc_map = BS_Search_locals_gc_map;
    int bs01;
    int right;
    int left;
    int var_cont;
    int medium;
    int aux01;
    int nt;
    frame.x_11 = 0;
    frame.x_12 = 0;
    frame.x_13 = 0;
    frame.x_14 = 0;

    aux01 = 0;
    bs01 = 0;
    right = *(thiss->number + 2);
    right = right - 1;
    left = 0;
    var_cont = 1;
    while(var_cont)
    {
        medium = left + right;
        medium = (frame.x_11=thiss, frame.x_11->vptr->Div(frame.x_11, medium));
        aux01 = (thiss->number + 4)[medium];
        if(num < aux01)
            right = medium - 1;
        else
            left = medium + 1;
        if((frame.x_12=thiss, frame.x_12->vptr->Compare(frame.x_12, aux01, num)))
        {
            var_cont = (frame.x_13=thiss, frame.x_13->vptr->Compare(frame.x_13, aux01, num));
            var_cont = 0;
        }
        else
            var_cont = 1;
        if(right < left)
            var_cont = 0;
        else
            nt = 0;
    }
    if((frame.x_14=thiss, frame.x_14->vptr->Compare(frame.x_14, aux01, num)))
        bs01 = 1;
    else
        bs01 = 0;
    previous = frame.prev;
    return bs01;
}

int BS_Div(struct BS * thiss, int num)
{
    struct BS_Div_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = BS_Div_arguments_gc_map;
    frame.arguments_base_address = (int *)&thiss;
    frame.locals_gc_map = BS_Div_locals_gc_map;
    int count01;
    int count02;
    int aux03;

    count01 = 0;
    count02 = 0;
    aux03 = num - 1;
    while(count02 < aux03)
    {
        count01 = count01 + 1;
        count02 = count02 + 2;
    }
    previous = frame.prev;
    return count01;
}

int BS_Compare(struct BS * thiss, int num1, int num2)
{
    struct BS_Compare_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = BS_Compare_arguments_gc_map;
    frame.arguments_base_address = (int *)&thiss;
    frame.locals_gc_map = BS_Compare_locals_gc_map;
    int retval;
    int aux02;

    retval = 0;
    aux02 = num2 + 1;
    if(num1 < num2)
        retval = 0;
    else
        if(!(num1 < aux02))
            retval = 0;
        else
            retval = 1;
    previous = frame.prev;
    return retval;
}

int BS_Print(struct BS * thiss)
{
    struct BS_Print_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = BS_Print_arguments_gc_map;
    frame.arguments_base_address = (int *)&thiss;
    frame.locals_gc_map = BS_Print_locals_gc_map;
    int j;

    j = 1;
    while(j < (thiss->size))
    {
        System_out_println((thiss->number + 4)[j]);
        j = j + 1;
    }
    System_out_println(99999);
    previous = frame.prev;
    return 0;
}

int BS_Init(struct BS * thiss, int sz)
{
    struct BS_Init_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = BS_Init_arguments_gc_map;
    frame.arguments_base_address = (int *)&thiss;
    frame.locals_gc_map = BS_Init_locals_gc_map;
    int j;
    int k;
    int aux02;
    int aux01;

    thiss->size = sz;
    thiss->number = ((int *)(Tiger_new_array(sz * sizeof(int))));
    j = 1;
    k = thiss->size + 1;
    while(j < (thiss->size))
    {
        aux01 = 2 * j;
        aux02 = k - 3;
        (thiss->number + 4)[j] = aux01 + aux02;
        j = j + 1;
        k = k - 1;
    }
    previous = frame.prev;
    return 0;
}

// main method
int Tiger_main()
{
    struct Tiger_main_gc_frame frame;
    frame.prev = previous;
    previous = &frame;
    frame.arguments_gc_map = 0;
    frame.arguments_base_address = 0;
    frame.locals_gc_map = Tiger_main_locals_gc_map;
    System_out_println((frame.x_0=((struct BS*)(Tiger_new(&BS_vtable_, sizeof(struct BS)))), frame.x_0->vptr->Start(frame.x_0, 20)));
}

